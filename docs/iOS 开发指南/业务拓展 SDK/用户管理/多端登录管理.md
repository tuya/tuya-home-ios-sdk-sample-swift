# 多端登录管理

## 功能概述

涂鸦智能 iOS SDK 提供了多端登录管理功能，允许用户查看和管理当前账号在所有设备上的登录状态。用户可以通过账号验证或密码验证的方式，安全地终止其他设备上的登录会话，确保账号安全。

## 接入准备

1. 确保项目依赖了最新版本的涂鸦全屋智能 SDK
2. 导入所需框架：
```swift
import ThingSmartHomeKit
```

## ThingSmartUser 多端登录管理接口详解

### 核心接口

#### 1. 获取登录设备列表

**接口说明**

获取当前账号在所有设备上的登录列表。

```objective-c
- (void)getLoginTerminalListWithSuccess:(nonnull void(^)( NSArray <ThingSmartLoginTerminalModel *> * __nullable))success
                                failure:(nullable ThingFailureError)failure;
```

**参数说明**

| 参数 | 说明 |
| ---- | ---- |
| success | 成功回调，返回 `ThingSmartLoginTerminalModel` 数组 |
| failure | 失败回调，返回错误信息 |

**ThingSmartLoginTerminalModel 属性说明**

| 属性 | 类型 | 说明 |
| ---- | ---- | ---- |
| terminalId | NSString | 设备唯一标识符 |
| platform | NSString | 设备平台名称 |
| os | NSString | 操作系统类型 |
| loginTime | NSTimeInterval | 登录时间戳 |

**示例代码**

Objc:

```objc
[[ThingSmartUser sharedInstance] getLoginTerminalListWithSuccess:^(NSArray<ThingSmartLoginTerminalModel *> *terminals) {
    self.loginTerminals = terminals ?: @[];
    [self.tableView reloadData];
} failure:^(NSError *error) {
    NSLog(@"Failed to get login terminals: %@", error.localizedDescription);
    [self showErrorAlert:error.localizedDescription];
}];
```

Swift:

```swift
ThingSmartUser.sharedInstance().getLoginTerminalList { terminals in
    self.loginTerminals = terminals ?? []
    self.tableView.reloadData()
} failure: { error in
    print("Failed to get login terminals: \(error?.localizedDescription ?? "Unknown error")")
    self.showErrorAlert(message: error?.localizedDescription ?? "Unknown error")
}
```

#### 2. 获取设备登出验证码

**接口说明**

通过账号验证或密码验证获取设备登出验证码，用于后续终止设备会话。支持两种验证方式：验证码验证和密码验证。

```objective-c
- (void)getLogoutCodeByAuthorizingAccount:(ThingSmartAccountAuthenticationRequestModel *)requestModel
                                success:(nullable void(^)(ThingSmartAccountAuthenticationModel *))success
                                failure:(nullable ThingFailureError)failure;
```

**参数说明**

| 参数 | 说明 |
| ---- | ---- |
| requestModel | 验证请求模型，包含账号信息和验证类型 |
| success | 成功回调，返回包含登出验证码的模型 |
| failure | 失败回调，返回错误信息 |

**ThingSmartAccountAuthenticationRequestModel 属性说明**

| 属性 | 类型 | 说明 |
| ---- | ---- | ---- |
| countryCode | NSString | 国家代码，如 "86" |
| userName | NSString | 用户名（邮箱或手机号，格式要求见下方说明） |
| authCode | NSString | 验证码（验证码验证时必填，6位数字） |
| password | NSString | 密码（密码验证时必填） |
| accountType | ThingSmartAuthenticationAccountType | 账号类型（.email 或 .phone） |
| verifyType | ThingSmartAuthenticationVerifyType | 验证类型（.authCode 或 .password） |
| ifencrypt | NSInteger | 是否加密（密码验证时设置为 1） |

**ThingSmartAccountAuthenticationModel 属性说明**

| 属性 | 类型 | 说明 |
| ---- | ---- | ---- |
| logoutCode | NSString | 登出验证码，用于终止设备会话 |

### 验证方式详解

#### 方式一：验证码验证

**适用场景**
- 用户已绑定邮箱或手机号
- 可以接收验证码的用户

**入参要求**

| 参数 | 值 | 说明 |
| ---- | ---- | ---- |
| countryCode | 用户的国家代码 | 如 "86" |
| userName | 邮箱或手机号 | 邮箱：完整邮箱地址<br>手机号：去掉国家代码和"-"的纯数字 |
| authCode | 6位数字验证码 | 必填，通过 sendVerifyCode 接口获取 |
| password | 不设置 | 验证码验证时不需要 |
| accountType | .email 或 .phone | 根据 userName 类型设置 |
| verifyType | .authCode | 固定值 |
| ifencrypt | 不设置 | 验证码验证时不需要 |

**userName 格式说明**
- **邮箱格式**：`user@example.com`
- **手机号格式**：
  - 原始格式：`86-13800138000`
  - 处理后格式：`13800138000`（去掉国家代码和"-"）

#### 方式二：密码验证

**适用场景**
- 手机号注册且没有绑定邮箱的用户
- 用户记得登录密码

**入参要求**

| 参数 | 值 | 说明 |
| ---- | ---- | ---- |
| countryCode | 用户的国家代码 | 如 "86" |
| userName | 手机号 | 去掉国家代码和"-"的纯数字 |
| authCode | 不设置 | 密码验证时不需要 |
| password | 用户登录密码 | 必填，原始密码 |
| accountType | .phone | 固定值，密码验证仅支持手机号 |
| verifyType | .password | 固定值 |
| ifencrypt | 1 | 固定值，表示密码加密传输 |

**userName 格式说明**
- **原始格式**：`86-13800138000`
- **处理后格式**：`13800138000`（去掉国家代码和"-"）

**示例代码**

#### 验证码验证示例

Objc:

```objc
// 方式一：验证码验证
ThingSmartAccountAuthenticationRequestModel *requestModel = [[ThingSmartAccountAuthenticationRequestModel alloc] init];
requestModel.countryCode = [ThingSmartUser sharedInstance].countryCode;

// 根据账号类型设置 userName
NSString *email = [ThingSmartUser sharedInstance].email;
NSString *phoneNumber = [ThingSmartUser sharedInstance].phoneNumber;

if (email.length > 0) {
    // 邮箱验证
    requestModel.userName = email;
    requestModel.accountType = ThingSmartAuthenticationAccountTypeEmail;
} else {
    // 手机号验证 - 去掉国家代码和"-"
    NSString *phone = phoneNumber;
    if ([phone containsString:@"-"]) {
        phone = [[phone componentsSeparatedByString:@"-"] lastObject];
    }
    requestModel.userName = phone;
    requestModel.accountType = ThingSmartAuthenticationAccountTypePhone;
}

requestModel.authCode = @"123456"; // 6位验证码
requestModel.verifyType = ThingSmartAuthenticationVerifyTypeAuthCode;

[[ThingSmartUser sharedInstance] getLogoutCodeByAuthorizingAccount:requestModel
                                                          success:^(ThingSmartAccountAuthenticationModel *authModel) {
    NSString *logoutCode = authModel.logoutCode;
    self.logoutCode = logoutCode;
    NSLog(@"Logout code obtained: %@", logoutCode);
} failure:^(NSError *error) {
    NSLog(@"Failed to get logout code: %@", error.localizedDescription);
}];
```

Swift:

```swift
// 方式一：验证码验证
let requestModel = ThingSmartAccountAuthenticationRequestModel()
requestModel.countryCode = ThingSmartUser.sharedInstance().countryCode

// 根据账号类型设置 userName
let email = ThingSmartUser.sharedInstance().email
let phoneNumber = ThingSmartUser.sharedInstance().phoneNumber

if !email.isEmpty {
    // 邮箱验证
    requestModel.userName = email
    requestModel.accountType = .email
} else {
    // 手机号验证 - 去掉国家代码和"-"
    var phone = phoneNumber
    if phone.contains("-") {
        phone = phone.components(separatedBy: "-").last ?? phone
    }
    requestModel.userName = phone
    requestModel.accountType = .phone
}

requestModel.authCode = "123456" // 6位验证码
requestModel.verifyType = .authCode

ThingSmartUser.sharedInstance().getLogoutCode(
    byAuthorizingAccount: requestModel,
    success: { authModel in
        let logoutCode = authModel.logoutCode
        self.logoutCode = logoutCode
        print("Logout code obtained: \(logoutCode ?? "")")
    },
    failure: { error in
        print("Failed to get logout code: \(error?.localizedDescription ?? "Unknown error")")
    }
)
```

#### 密码验证示例

Objc:

```objc
// 方式二：密码验证
ThingSmartAccountAuthenticationRequestModel *requestModel = [[ThingSmartAccountAuthenticationRequestModel alloc] init];
requestModel.countryCode = [ThingSmartUser sharedInstance].countryCode;

// 处理手机号格式 - 去掉国家代码和"-"
NSString *phoneNumber = [ThingSmartUser sharedInstance].phoneNumber;
NSString *phone = phoneNumber;
if ([phone containsString:@"-"]) {
    phone = [[phone componentsSeparatedByString:@"-"] lastObject];
}
requestModel.userName = phone;

requestModel.password = @"userPassword"; // 用户登录密码
requestModel.accountType = ThingSmartAuthenticationAccountTypePhone; // 固定为手机号
requestModel.verifyType = ThingSmartAuthenticationVerifyTypePassword;
requestModel.ifencrypt = 1; // 密码加密传输

[[ThingSmartUser sharedInstance] getLogoutCodeByAuthorizingAccount:requestModel
                                                          success:^(ThingSmartAccountAuthenticationModel *authModel) {
    NSString *logoutCode = authModel.logoutCode;
    self.logoutCode = logoutCode;
    NSLog(@"Logout code obtained: %@", logoutCode);
} failure:^(NSError *error) {
    NSLog(@"Failed to get logout code: %@", error.localizedDescription);
}];
```

Swift:

```swift
// 方式二：密码验证
let requestModel = ThingSmartAccountAuthenticationRequestModel()
requestModel.countryCode = ThingSmartUser.sharedInstance().countryCode

// 处理手机号格式 - 去掉国家代码和"-"
let phoneNumber = ThingSmartUser.sharedInstance().phoneNumber
var phone = phoneNumber
if phone.contains("-") {
    phone = phone.components(separatedBy: "-").last ?? phone
}
requestModel.userName = phone

requestModel.password = "userPassword" // 用户登录密码
requestModel.accountType = .phone // 固定为手机号
requestModel.verifyType = .password
requestModel.ifencrypt = 1 // 密码加密传输

ThingSmartUser.sharedInstance().getLogoutCode(
    byAuthorizingAccount: requestModel,
    success: { authModel in
        let logoutCode = authModel.logoutCode
        self.logoutCode = logoutCode
        print("Logout code obtained: \(logoutCode ?? "")")
    },
    failure: { error in
        print("Failed to get logout code: \(error?.localizedDescription ?? "Unknown error")")
    }
)
```

#### 3. 终止设备会话

**接口说明**

使用登出验证码强制终止指定设备上的登录会话。

```objective-c
- (void)terminateSessionOnDevice:(NSString *)terminalId
                      logoutCode:(NSString *)logoutCode
                         success:(nullable ThingSuccessBOOL)success
                         failure:(nullable ThingFailureError)failure;
```

**参数说明**

| 参数 | 说明 |
| ---- | ---- |
| terminalId | 设备唯一标识符 |
| logoutCode | 登出验证码（从 getLogoutCodeByAuthorizingAccount 获取） |
| success | 成功回调，返回 BOOL 值表示是否成功终止会话 |
| failure | 失败回调，返回错误信息 |

**示例代码**

Objc:

```objc
[[ThingSmartUser sharedInstance] terminateSessionOnDevice:terminal.terminalId
                                               logoutCode:self.logoutCode
                                                  success:^(BOOL success) {
    if (success) {
        NSLog(@"Device session terminated successfully");
        // 从列表中移除设备
        [self.loginTerminals removeObject:terminal];
        [self.tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationFade];
    } else {
        NSLog(@"Failed to terminate device session");
        [self showErrorAlert:@"Failed to terminate device session"];
    }
} failure:^(NSError *error) {
    NSLog(@"Failed to terminate device session: %@", error.localizedDescription);
    [self showErrorAlert:error.localizedDescription];
}];
```

Swift:

```swift
ThingSmartUser.sharedInstance().terminateSession(
    onDevice: terminal.terminalId,
    logoutCode: self.logoutCode
) { success in
    if success {
        print("Device session terminated successfully")
        // 从列表中移除设备
        self.loginTerminals.remove(at: indexPath.row)
        self.tableView.deleteRows(at: [indexPath], with: .fade)
    } else {
        print("Failed to terminate device session")
        self.showErrorAlert(message: "Failed to terminate device session")
    }
} failure: { error in
    print("Failed to terminate device session: \(error?.localizedDescription ?? "Unknown error")")
    self.showErrorAlert(message: error?.localizedDescription ?? "Unknown error")
}
```
**监听账号退出通知**

当用户在其他设备上被登出时，当前设备需要监听退出通知并处理相应的逻辑。

```objective-c
// 添加通知监听
[[NSNotificationCenter defaultCenter] addObserver:self
                                         selector:@selector(handleUserLogout:)
                                             name:ThingSmartUserNotificationUserSessionInvalid
                                           object:nil];

// 处理退出通知
- (void)handleUserLogout:(NSNotification *)notification {
    dispatch_async(dispatch_get_main_queue(), ^{
        // 显示退出提示
        UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"账号已退出"
                                                                       message:@"您的账号已在其他设备上退出，请重新登录"
                                                                preferredStyle:UIAlertControllerStyleAlert];
        
        UIAlertAction *okAction = [UIAlertAction actionWithTitle:@"确定"
                                                           style:UIAlertActionStyleDefault
                                                         handler:^(UIAlertAction * _Nonnull action) {
            // 跳转到登录页面
            [self.navigationController popToRootViewControllerAnimated:YES];
        }];
        
        [alert addAction:okAction];
        [self presentViewController:alert animated:YES completion:nil];
    });
}

// 移除通知监听
- (void)dealloc {
    [[NSNotificationCenter defaultCenter] removeObserver:self];
}
```

Swift:

```swift
// 添加通知监听
NotificationCenter.default.addObserver(
    self,
    selector: #selector(handleUserLogout(_:)),
    name: NSNotification.Name.ThingSmartUserNotificationUserSessionInvalid,
    object: nil
)

// 处理退出通知
@objc private func handleUserLogout(_ notification: Notification) {
    DispatchQueue.main.async {
        // 显示退出提示
        let alert = UIAlertController(
            title: "账号已退出",
            message: "您的账号已在其他设备上退出，请重新登录",
            preferredStyle: .alert
        )
        
        let okAction = UIAlertAction(title: "确定", style: .default) { _ in
            // 跳转到登录页面
            self.navigationController?.popToRootViewController(animated: true)
        }
        
        alert.addAction(okAction)
        self.present(alert, animated: true)
    }
}

// 移除通知监听
deinit {
    NotificationCenter.default.removeObserver(self)
}
```

## 核心功能实现

### 1. 多端登录管理页面初始化

```swift
class MultiDeviceLoginViewController: UIViewController {
    private var loginTerminals: [ThingSmartLoginTerminalModel] = []
    private var authModel: ThingSmartAccountAuthenticationModel?
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupUI()
        loadLoginTerminals()
    }
}
```

### 2. 加载登录设备列表

```swift
private func loadLoginTerminals() {
    ThingSmartUser.sharedInstance().getLoginTerminalList { [weak self] terminals in
        DispatchQueue.main.async {
            self?.loginTerminals = terminals ?? []
            self?.tableView.reloadData()
        }
    } failure: { [weak self] error in
        DispatchQueue.main.async {
            self?.showErrorAlert(message: "获取登录设备列表失败: \(error?.localizedDescription ?? "未知错误")")
        }
    }
}
```

### 3. 账号验证获取登出码

```swift
private func verifyCode() {
    let requestModel = ThingSmartAccountAuthenticationRequestModel()
    requestModel.countryCode = ThingSmartUser.sharedInstance().countryCode
    requestModel.userName = displayAccount
    requestModel.authCode = verificationCode
    requestModel.accountType = .email // 或 .phone
    requestModel.verifyType = .authCode
    
    ThingSmartUser.sharedInstance().getLogoutCode(
        byAuthorizingAccount: requestModel,
        success: { [weak self] result in
            DispatchQueue.main.async {
                // 验证成功，保存登出码
                self?.authModel = result
                self?.showSuccessAlert()
            }
        },
        failure: { [weak self] error in
            DispatchQueue.main.async {
                self?.showErrorAlert(message: "验证失败: \(error?.localizedDescription ?? "未知错误")")
            }
        }
    )
}
```

### 4. 密码验证获取登出码

```swift
private func verifyPassword() {
    let requestModel = ThingSmartAccountAuthenticationRequestModel()
    requestModel.countryCode = ThingSmartUser.sharedInstance().countryCode
    
    // 处理手机号格式（去掉国家代码和"-"）
    let phone = ThingSmartUser.sharedInstance().phoneNumber
    if phone.contains("-") {
        requestModel.userName = phone.components(separatedBy: "-").last ?? phone
    } else {
        requestModel.userName = phone
    }
    
    requestModel.password = password
    requestModel.accountType = .phone
    requestModel.verifyType = .password
    
    ThingSmartUser.sharedInstance().getLogoutCode(
        byAuthorizingAccount: requestModel,
        success: { [weak self] result in
            DispatchQueue.main.async {
                // 验证成功，保存登出码
                self?.authModel = result
                self?.showSuccessAlert()
            }
        },
        failure: { [weak self] error in
            DispatchQueue.main.async {
                self?.showErrorAlert(message: "密码验证失败: \(error?.localizedDescription ?? "未知错误")")
            }
        }
    )
}
```

### 5. 终止设备会话

```swift
private func performLogout(terminal: ThingSmartLoginTerminalModel, at indexPath: IndexPath) {
    guard let authModel = self.authModel, let logoutCode = authModel.logoutCode else {
        showErrorAlert(message: "验证信息已过期，请重新验证")
        return
    }
    
    ThingSmartUser.sharedInstance().terminateSession(
        onDevice: terminal.terminalId,
        logoutCode: logoutCode
    ) { [weak self] success in
        DispatchQueue.main.async {
            if success {
                self?.loginTerminals.remove(at: indexPath.row)
                self?.tableView.deleteRows(at: [indexPath], with: .fade)
                self?.showSuccessAlert(message: "设备登出成功")
            } else {
                self?.showErrorAlert(message: "设备登出失败")
            }
        }
    } failure: { [weak self] error in
        DispatchQueue.main.async {
            self?.showErrorAlert(message: "设备登出失败: \(error?.localizedDescription ?? "未知错误")")
        }
    }
}
```

### 6. 发送验证码

```swift
private func sendVerificationCode() {
    let email = ThingSmartUser.sharedInstance().email
    let phoneNumber = ThingSmartUser.sharedInstance().phoneNumber
    
    // 按照逻辑：优先使用邮箱，如果邮箱无效则使用手机号的后半部分
    let accountText: String
    if isValidEmail(email) {
        accountText = email
    } else if !phoneNumber.isEmpty {
        let components = phoneNumber.components(separatedBy: "-")
        accountText = components.last ?? phoneNumber
    } else {
        showErrorAlert(message: "无法获取账号信息")
        return
    }
    
    ThingSmartUser.sharedInstance().sendVerifyCode(
        withUserName: accountText,
        region: ThingSmartUser.sharedInstance().regionCode,
        countryCode: ThingSmartUser.sharedInstance().countryCode,
        type: 10
    ) { [weak self] in
        DispatchQueue.main.async {
            self?.updateInstructionText()
        }
    } failure: { [weak self] error in
        DispatchQueue.main.async {
            self?.showErrorAlert(message: "发送验证码失败: \(error?.localizedDescription ?? "未知错误")")
        }
    }
}
```

## 使用流程

### 1. 基本流程

1. 调用 `getLoginTerminalList` 获取登录设备列表
2. 用户选择要登出的设备
3. 进行安全验证（账号验证或密码验证）
4. 调用 `getLogoutCodeByAuthorizingAccount` 获取登出验证码
5. 调用 `terminateSessionOnDevice` 终止设备会话

### 2. 账号验证流程

1. 用户输入验证码
2. 调用 `sendVerifyCode` 发送验证码（如需要）
3. 调用 `getLogoutCodeByAuthorizingAccount` 进行验证码验证
4. 获取登出验证码后可以终止设备会话

### 3. 密码验证流程

1. 用户输入登录密码
2. 调用 `getLogoutCodeByAuthorizingAccount` 进行密码验证
3. 获取登出验证码后可以终止设备会话

## 注意事项

1. **验证方式选择**：
   - **验证码验证**：适用于已绑定邮箱或手机号的用户，需要先调用 `sendVerifyCode` 发送验证码
   - **密码验证**：仅适用于手机号注册且没有绑定邮箱的用户
2. **userName 格式要求**：
   - **邮箱格式**：完整邮箱地址，如 `user@example.com`
   - **手机号格式**：去掉国家代码和"-"的纯数字，如 `13800138000`
3. **参数设置要求**：
   - **验证码验证**：必须设置 `authCode`，不需要设置 `password` 和 `ifencrypt`
   - **密码验证**：必须设置 `password` 和 `ifencrypt=1`，不需要设置 `authCode`
4. **登出码有效期**：获取的登出验证码有时效性，建议及时使用
5. **错误处理**：所有接口调用都应该处理失败情况，给用户适当的错误提示
6. **UI更新**：网络请求的回调中更新UI时，确保在主线程执行

## 常见问题

### 1. 验证码验证失败
- 检查验证码是否正确（6位数字）
- 验证码是否过期（通常5-10分钟有效）
- 检查 userName 格式是否正确
- 确认是否已调用 `sendVerifyCode` 发送验证码

### 2. 密码验证失败
- 检查密码是否正确
- 确认账号类型为手机号且未绑定邮箱
- 检查 userName 格式（去掉国家代码和"-"）
- 确认设置了 `ifencrypt=1`

### 3. 设备登出失败
- 检查登出验证码是否有效
- 确认设备ID是否正确
- 网络连接是否正常

### 4. 接口调用顺序
- 必须先获取登出验证码，才能终止设备会话
- 验证码验证和密码验证是两种不同的验证方式，不能混用


